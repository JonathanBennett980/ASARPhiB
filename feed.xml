<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="http://localhost:4000/ASARPhiB/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/ASARPhiB/" rel="alternate" type="text/html" /><updated>2018-02-13T17:55:55+01:00</updated><id>http://localhost:4000/ASARPhiB/</id><title type="html">ASARPhiB</title><subtitle>ASARPhiB: Simple Almost Rigorous Philosophical Blog&lt;br /&gt;&lt;small&gt;Or just a hASARdous Philosophical Blog&lt;/small&gt;</subtitle><entry><title type="html">The Rules of Inference</title><link href="http://localhost:4000/ASARPhiB/rules-of-inference" rel="alternate" type="text/html" title="The Rules of Inference" /><published>2018-02-10T19:39:00+01:00</published><updated>2018-02-10T19:39:00+01:00</updated><id>http://localhost:4000/ASARPhiB/rules-of-inference</id><content type="html" xml:base="http://localhost:4000/ASARPhiB/rules-of-inference">&lt;p&gt;Simple binary operators aren’t a structure powerful enough to define rules of reasoning.
This is where rules of inference come into play.
They are forms of reasoning that we can prove to be correct.
Let’s discover a few of them.&lt;/p&gt;

&lt;p&gt;This article is the fourth in a series of four:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;/ASARPhiB//intro-to-boolean-logic&quot;&gt;Boolean Logic&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/ASARPhiB//complex-boolean-operators&quot;&gt;“Complex” Boolean Operators&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/ASARPhiB//boolean-algebra&quot;&gt;Boolean Algebra&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/ASARPhiB//rules-of-inference&quot;&gt;Rules of Inference&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;rules-of-inference&quot;&gt;Rules of Inference&lt;/h1&gt;

&lt;p&gt;The general idea is the following: some propositions \( P_1 \), …, \( P_n \) are assumed to be true and one shows that accepting those propositions logically (in the sense of boolean logic) leads to saying that a conclusion proposition \( P_c \) must also be true.&lt;/p&gt;

&lt;p&gt;\( P_1 \) to \( P_n \) are called the premises.
 \( P_c \) is called the conclusion.&lt;/p&gt;

&lt;p&gt;There are quite many rules of inferences, here I will only cite the most useful ones.
Note that the rules of inferences do &lt;em&gt;not&lt;/em&gt; concern themselves with the truth of the premises.
They are only used to deduce conclusions &lt;em&gt;when we assume the premises to be true&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;modus-ponens&quot;&gt;Modus Ponens&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(P \wedge (P\rightarrow Q)) \rightarrow Q \leftrightarrow \text{true}&lt;/script&gt;

&lt;p&gt;This form of argumentation is based on two premises:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;\( P\rightarrow Q \) (The proposition “if \( P \) is true, then \( Q \) is true” is true)&lt;/li&gt;
  &lt;li&gt;\( P \) ( \( P \) is true)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;From this, we can conclude that \( Q \) is true.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;If you are rich, then you are beautiful&lt;/li&gt;
  &lt;li&gt;You are rich&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It follows logically that you are beautiful!&lt;/p&gt;

&lt;p&gt;It is possible to prove these rules using the boolean algebra defined in a &lt;a href=&quot;/ASARPhiB//intro-to-boolean-logic&quot;&gt;previous article&lt;/a&gt;.
The proof for this rule of inference is given thereafter.
The proofs for the others rules of inference will not be given.
One can find them online or derive them using boolean algebra.&lt;/p&gt;

&lt;p&gt;This is proof is given for the sake of example but is not explained in detailed:
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\begin{aligned}
(P \wedge (P \rightarrow Q)) \rightarrow Q &amp;\leftrightarrow \neg (P \wedge (P \rightarrow Q)) \vee Q\\
  &amp; \leftrightarrow (\bar P \vee \neg (P \rightarrow Q)) \vee Q\\
  &amp; \leftrightarrow (\bar P \vee (P \wedge \bar Q)) \vee Q\\
  &amp; \leftrightarrow (\bar P \wedge (Q \vee \bar Q)) \vee (P \wedge \bar Q) \vee (Q \wedge (P \vee \bar P))\\
  &amp; \leftrightarrow (\bar P \wedge Q) \vee (\bar P \wedge \bar Q) \vee (P\wedge Q) \vee (\bar P \wedge Q)\\
  &amp; \leftrightarrow \text{True}
\end{aligned} %]]&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h2 id=&quot;modus-tolens&quot;&gt;Modus Tolens&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(\neg Q \wedge (P\rightarrow Q)) \rightarrow \neg P \leftrightarrow \text{true}&lt;/script&gt;

&lt;p&gt;This form of argumentation is based on two premises:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;\( P\rightarrow Q \) (The proposition “if \( P \) is true, then \( Q \) is true” is true)&lt;/li&gt;
  &lt;li&gt;\( \neg Q \) ( \( Q \) is false)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;From this, we can conclude that \( P \) is false.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;If you are rich, then you are beautiful&lt;/li&gt;
  &lt;li&gt;You are not beautiful&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It follows logically that you are not rich!&lt;/p&gt;

&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h1&gt;

&lt;h2 id=&quot;on-rules-of-inference&quot;&gt;On Rules of Inference&lt;/h2&gt;

&lt;p&gt;There exist a few more rules of inference.
They can also be extended to use the mathematical symbols &lt;script type=&quot;math/tex&quot;&gt;\forall&lt;/script&gt; (for all) and &lt;script type=&quot;math/tex&quot;&gt;\exists&lt;/script&gt; (it exists).
More informations about them can be found on &lt;a href=&quot;https://en.wikipedia.org/wiki/List_of_rules_of_inference&quot;&gt;Wikipedia&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I will try, in this blog, to be almost rigorous in the philosophical points I want to make; i.e. formulate them with rules of inference.&lt;/p&gt;

&lt;h2 id=&quot;on-philosophy&quot;&gt;On Philosophy&lt;/h2&gt;

&lt;p&gt;We saw that rules of inference only concern themselves with the articulation one can formulate between premises to deduce a conclusion.
So the whole debate is now shifted toward finding the correct premises or toward finding premises that can be accepted by everyone.&lt;/p&gt;

&lt;p&gt;The conclusions will logically follow.&lt;/p&gt;</content><author><name>Jonathan Bennett</name></author><category term="Getting started" /><category term="Logic" /><summary type="html">Simple binary operators aren’t a structure powerful enough to define rules of reasoning. This is where rules of inference come into play. They are forms of reasoning that we can prove to be correct. Let’s discover a few of them.</summary></entry><entry><title type="html">Boolean Algebra</title><link href="http://localhost:4000/ASARPhiB/boolean-algebra" rel="alternate" type="text/html" title="Boolean Algebra" /><published>2018-02-10T19:39:00+01:00</published><updated>2018-02-10T19:39:00+01:00</updated><id>http://localhost:4000/ASARPhiB/boolean-algebra</id><content type="html" xml:base="http://localhost:4000/ASARPhiB/boolean-algebra">&lt;p&gt;Binary operators are simple.
Nevertheless some non-trivial rules can be applied to them to make appear some other forms of an identical expression which allows us, for example, to make simplifications.&lt;/p&gt;

&lt;p&gt;This article is the third article in a series of four:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;/ASARPhiB//intro-to-boolean-logic&quot;&gt;Boolean Logic&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/ASARPhiB//complex-boolean-operators&quot;&gt;“Complex” Boolean Operators&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/ASARPhiB//boolean-algebra&quot;&gt;Boolean Algebra&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/ASARPhiB//rules-of-inference&quot;&gt;Rules of Inference&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;negation-of-a-negation&quot;&gt;Negation of a Negation&lt;/h1&gt;

&lt;p&gt;This rule is trivially proven by computing the truthtable of each expression.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg (\neg P) \leftrightarrow P&lt;/script&gt;

&lt;h1 id=&quot;de-morgan-laws&quot;&gt;De Morgan Laws&lt;/h1&gt;

&lt;p&gt;The De Morgan Laws state the following:&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\neg(A \vee B) \leftrightarrow \bar A \wedge  \bar B&lt;/script&gt;
and
&lt;script type=&quot;math/tex&quot;&gt;\neg (A \wedge B) \leftrightarrow \bar A \vee  \bar B&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;One can see this is true by putting side-to-side the thruthtables of the expressions on each side of the equivalence.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;\( A \)&lt;/th&gt;
      &lt;th&gt;\( B \)&lt;/th&gt;
      &lt;th&gt;\( A \vee B \)&lt;/th&gt;
      &lt;th&gt;\( \bar A \)&lt;/th&gt;
      &lt;th&gt;\( \bar B \)&lt;/th&gt;
      &lt;th&gt;\( \bar A \wedge \bar B \)&lt;/th&gt;
      &lt;th&gt;\(\neg(\bar A \wedge \bar B)\)&lt;/th&gt;
      &lt;th&gt;\(A \vee B \leftrightarrow \neg(\bar A \wedge  \bar B)\)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;if-then-equivalence&quot;&gt;If Then Equivalence&lt;/h1&gt;

&lt;p&gt;We also pretend \( A \rightarrow B \leftrightarrow \neg A \vee B \).
Again, this can be demonstrated by putting the thruthtables side-to-side.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;\( A \)&lt;/th&gt;
      &lt;th&gt;\( B \)&lt;/th&gt;
      &lt;th&gt;\( A \rightarrow B \)&lt;/th&gt;
      &lt;th&gt;\( \neg A \)&lt;/th&gt;
      &lt;th&gt;\( \neg A \vee B \)&lt;/th&gt;
      &lt;th&gt;\( A \rightarrow B \leftrightarrow \neg A \vee B \)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;equivalence-equivalent-expression&quot;&gt;Equivalence Equivalent Expression&lt;/h1&gt;

&lt;p&gt;We give this last equivalence without proof, but it can easily be proved by a truthtable or by looking at the definition of the &lt;em&gt;equivalence&lt;/em&gt; operator:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A \leftrightarrow B \equiv (A \wedge B) \vee (\bar A \wedge \bar B)&lt;/script&gt;

&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;With these simple rules of boolean algebra, we are now ready to prove what correct forms of reasoning are.
This will be the topic of the next article: &lt;a href=&quot;/ASARPhiB//rules-of-inference&quot;&gt;Rules of Inference&lt;/a&gt;.&lt;/p&gt;</content><author><name>Jonathan Bennett</name></author><category term="Getting started" /><category term="Logic" /><summary type="html">Binary operators are simple. Nevertheless some non-trivial rules can be applied to them to make appear some other forms of an identical expression which allows us, for example, to make simplifications.</summary></entry><entry><title type="html">“Complex” Boolean Operators</title><link href="http://localhost:4000/ASARPhiB/complex-boolean-operators" rel="alternate" type="text/html" title="&quot;Complex&quot; Boolean Operators" /><published>2018-02-10T19:34:00+01:00</published><updated>2018-02-10T19:34:00+01:00</updated><id>http://localhost:4000/ASARPhiB/complex-boolean-operators</id><content type="html" xml:base="http://localhost:4000/ASARPhiB/complex-boolean-operators">&lt;p&gt;The boolean operators &lt;em&gt;negation&lt;/em&gt;, &lt;em&gt;AND&lt;/em&gt; and &lt;em&gt;OR&lt;/em&gt; suffice to represent all expressions.
However, it might some time be easier to define a few more operators for the sake of simplicity.
In this article, I will cover the &lt;em&gt;if then&lt;/em&gt; and &lt;em&gt;equivalence&lt;/em&gt; operators.&lt;/p&gt;

&lt;p&gt;This article is the second article in a series of four:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;/ASARPhiB//intro-to-boolean-logic&quot;&gt;Boolean Logic&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/ASARPhiB//complex-boolean-operators&quot;&gt;“Complex” Boolean Operators&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/ASARPhiB//boolean-algebra&quot;&gt;Boolean Algebra&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/ASARPhiB//rules-of-inference&quot;&gt;Rules of Inference&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;two-more-binary-operators&quot;&gt;Two More Binary Operators&lt;/h1&gt;

&lt;h2 id=&quot;implies-if--then-&quot;&gt;Implies (if … then …)&lt;/h2&gt;

&lt;p&gt;Let’s define the implication operator \( \rightarrow \).
It is a binary operator with the following truthtable:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;\( A \)&lt;/th&gt;
      &lt;th&gt;\( B \)&lt;/th&gt;
      &lt;th&gt;\( C = A \rightarrow B \)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;F&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;We remark that \( C \) is false only when \( A \) is true and \( B \) is false.&lt;/p&gt;

&lt;p&gt;I pretend that this operator is equivalent to saying “if A, then B”.&lt;/p&gt;

&lt;p&gt;Let us define three propositions:&lt;/p&gt;

&lt;p&gt;\( A \) = “I am elected maire”&lt;/p&gt;

&lt;p&gt;\( B \) = “I increase taxes”&lt;/p&gt;

&lt;p&gt;\( C \) = \( A \rightarrow B \)&lt;/p&gt;

&lt;p&gt;I will now try to prove that this is the same as the sentence “If I am elected maire, then I will increase the taxes”.&lt;/p&gt;

&lt;p&gt;Imagine a politician P, saying “If I am elected maire, then I will increase the taxes”.
If P is elected and he/she raises the taxes then he did not lie and C is true.
If P is elected but he/she does not increase the taxes, then he/she lied and the proposition was in fact false.
If P is not elected, then he/she said the truth when saying that if he/she got elected, he/she would raise the taxes in the sense that the person did not lie.
We see the exact same values in the truthtable of the implication operator.&lt;/p&gt;

&lt;h2 id=&quot;equivalence&quot;&gt;Equivalence&lt;/h2&gt;

&lt;p&gt;Let us finally define the binary operator equivalence represented with the symbol \( \leftrightarrow \) with the following truthtable:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;\( A \)&lt;/th&gt;
      &lt;th&gt;\( B \)&lt;/th&gt;
      &lt;th&gt;\( A \leftrightarrow B \)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;F&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;F&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;I pretend that the equivalence operator applied to two propositions is equivalent to saying that two propositions are equivalent.
This comes from the fact that for two propositions to be equivalent, they need, for any given input, to be either both true or both false, but they cannot have different values.
One can remark that this is exactly what the truthtable says.&lt;/p&gt;

&lt;h2 id=&quot;extended-precedence-rules&quot;&gt;Extended Precedence Rules&lt;/h2&gt;

&lt;p&gt;We already saw the rules of precedence for the &lt;em&gt;negation&lt;/em&gt;, &lt;em&gt;AND&lt;/em&gt; and &lt;em&gt;OR&lt;/em&gt; operators.
We now complete those rules with the two newly defined operators.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Negation&lt;/li&gt;
  &lt;li&gt;AND&lt;/li&gt;
  &lt;li&gt;OR&lt;/li&gt;
  &lt;li&gt;Implication&lt;/li&gt;
  &lt;li&gt;Equivalence&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;more-binary-operators&quot;&gt;More binary operators&lt;/h2&gt;

&lt;p&gt;There exists many more binary operators (XOR, XAND, etc) but the ones above are generally enough.&lt;/p&gt;

&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;With those tools in hand, we are ready to discover some simple rules of algebra that govern the world of logic and that we will later use to prove what a correct reasoning is.
Simple rules of algebra will be the topic of the next article: &lt;a href=&quot;/ASARPhiB//boolean-algebra&quot;&gt;Boolean Algebra&lt;/a&gt;
.&lt;/p&gt;</content><author><name>Jonathan Bennett</name></author><category term="Getting started" /><category term="Logic" /><summary type="html">The boolean operators negation, AND and OR suffice to represent all expressions. However, it might some time be easier to define a few more operators for the sake of simplicity. In this article, I will cover the if then and equivalence operators.</summary></entry><entry><title type="html">An Introduction to Boolean Logic</title><link href="http://localhost:4000/ASARPhiB/intro-to-boolean-logic" rel="alternate" type="text/html" title="An Introduction to Boolean Logic" /><published>2018-01-27T16:27:00+01:00</published><updated>2018-01-27T16:27:00+01:00</updated><id>http://localhost:4000/ASARPhiB/intro-to-boolean-logic</id><content type="html" xml:base="http://localhost:4000/ASARPhiB/intro-to-boolean-logic">&lt;p&gt;A strong and correct reasoning must, at the very least, be rooted in a rock solid logic.
This article tries to explain the basics of the boolean logic, one of the most commonly used logic in mathematics.&lt;/p&gt;

&lt;p&gt;It is the first article in a series of four:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;/ASARPhiB//intro-to-boolean-logic&quot;&gt;Boolean Logic&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/ASARPhiB//complex-boolean-operators&quot;&gt;“Complex” Boolean Operators&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/ASARPhiB//boolean-algebra&quot;&gt;Boolean Algebra&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/ASARPhiB//rules-of-inference&quot;&gt;Rules of Inference&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The final goal of this series is to derive the so-called rules of inference that are rules to apply for correct reasoning.&lt;/p&gt;

&lt;h1 id=&quot;some-definitions&quot;&gt;Some Definitions&lt;/h1&gt;

&lt;h2 id=&quot;proposition&quot;&gt;Proposition&lt;/h2&gt;

&lt;dl&gt;
  &lt;dt&gt;Proposition&lt;/dt&gt;
  &lt;dd&gt;Let’s define a &lt;em&gt;proposition&lt;/em&gt; \( P \) as a sentence that can either be &lt;em&gt;true&lt;/em&gt; or &lt;em&gt;false&lt;/em&gt;, and nothing else (law of excluded middle).&lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;&lt;em&gt;Example: \( P \) = “It is snowing”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Remark: Some might argue that, in real life, a perfect binarity most often doesn’t exist.
It is more likely that a property can take a value in a gradient of possible values.
I totally agree with this point of view.
But I think it is still possible to define propositions that are either true or false but nothing else, by considering ranges of values.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;For example, assume I define \( P \) as “X has brown hair”.
X might have dark brow hair, or aubrun hair…
Is \( P \) true or false then?
One possible solution is to better define the proposition \( P \) as “X has hair that are brown or darker”.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;compound-proposition&quot;&gt;Compound Proposition&lt;/h2&gt;

&lt;dl&gt;
  &lt;dt&gt;Compound Proposition&lt;/dt&gt;
  &lt;dd&gt;I now define a &lt;em&gt;compound proposition&lt;/em&gt; as a proposition that is defined by relationships between other propositions.
I will call the other propositions &lt;em&gt;input propositions&lt;/em&gt;.
The relationships are defined using &lt;em&gt;operators&lt;/em&gt;.
We will see a few of them below.&lt;/dd&gt;
  &lt;dt&gt;Truthtable&lt;/dt&gt;
  &lt;dd&gt;Let’s also define the &lt;em&gt;truthtable&lt;/em&gt; of a compound proposition as a table showing all the possible values that the input propositions can take and the value that the compound proposition take given the values of the input propositions.
For conciseness, &lt;em&gt;true&lt;/em&gt; will be written &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; and &lt;em&gt;false&lt;/em&gt; will be written &lt;code class=&quot;highlighter-rouge&quot;&gt;F&lt;/code&gt; inside truthtables.&lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;To create a compound proposition, one must link or combine one or more propositions together.
To combine propositions one uses so-called operators, they simply represent the kind of relationship there is between two propositions.&lt;/p&gt;

&lt;p&gt;I will now define a few ways to combine propositions using unary and binary operators (operators that are applied on a single proposition or two propositions respectively).&lt;/p&gt;

&lt;h1 id=&quot;operators&quot;&gt;Operators&lt;/h1&gt;

&lt;h2 id=&quot;negation&quot;&gt;Negation&lt;/h2&gt;

&lt;p&gt;Let’s define a unary operation on a proposition called the negation of a proposition in the following way, the negation of a proposition that is &lt;em&gt;true&lt;/em&gt; will yield &lt;em&gt;false&lt;/em&gt;, the negation of a proposition that is &lt;em&gt;false&lt;/em&gt; will yield &lt;em&gt;true&lt;/em&gt;.
The negation of a proposition \( P \) is represented in the following way: \( \neg P \).
A second way to represent the negation of \( P \) is \( \bar P \).
I will use one or the other depending on which is more comfortable to read in a given context.&lt;/p&gt;

&lt;p&gt;Here is the truthtable of the negation operation:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;\( P \)&lt;/th&gt;
      &lt;th&gt;\( \bar{P} \)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;F&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;I will now try to show that the negation operation corresponds to the negation as we understand it in the english language.&lt;/p&gt;

&lt;p&gt;Let me define \( P \) as “It is snowing”.
This can either be &lt;em&gt;true&lt;/em&gt; or &lt;em&gt;false&lt;/em&gt;.
Let me also remark that \( P \) yields &lt;em&gt;true&lt;/em&gt; when it is snowing and &lt;em&gt;false&lt;/em&gt; otherwise.&lt;/p&gt;

&lt;p&gt;I pretend that the negation of a proposition is equivalent to the negation of the sentence that the proposition represent.
I am not sure if it is even possible to make a rigorous proof of this.
I can only hope that the following example convinces you, that you find it obvious enough or that someone propose us a proper proof of it.
This remark is valid for all following operators where I try to show the correspondences to the human language.&lt;/p&gt;

&lt;p&gt;We now consider \( \bar{P} \).
By the definition of the negation operator, \( \bar{P} \) will yield &lt;em&gt;false&lt;/em&gt; when it snows and &lt;em&gt;true&lt;/em&gt; when it is not snowing.
This is equivalent to the proposition “It is not snowing” because it yield &lt;em&gt;true&lt;/em&gt; when it is not snowing and &lt;em&gt;false&lt;/em&gt; when it is snowing.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Axiom&lt;/strong&gt;: For a proposition defined as a sentence, the negation operation on the proposition is the same as the negation as we understand it in the English language of the sentence.&lt;/p&gt;

&lt;h2 id=&quot;and&quot;&gt;AND&lt;/h2&gt;

&lt;p&gt;Let me represent the AND operator with the following symbol: \( \wedge \).
The AND-composition of two propositions \( A \) and \( B \) is then represented the following way: \( A \wedge B \)&lt;/p&gt;

&lt;p&gt;Furthermore, I define the truthtable of the AND-operator as follow:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;\( A \)&lt;/th&gt;
      &lt;th&gt;\( B \)&lt;/th&gt;
      &lt;th&gt;\( A\wedge B \)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;F&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;F&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;F&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;In other words, \( A \wedge B \) is true if and only if \( A \) is true and \( B \) is true simultaneously.&lt;/p&gt;

&lt;p&gt;I pretend that the AND operator on two propositions \( A \) and \( B \) is equivalent to saying “A and B” as we understand it in the English language.&lt;/p&gt;

&lt;p&gt;Let’s consider the following propositions:&lt;/p&gt;

&lt;p&gt;\( A \) = “I have brown eyes”&lt;/p&gt;

&lt;p&gt;\( B \) = “I possess a car”&lt;/p&gt;

&lt;p&gt;\( C \) = \( A \wedge B \)&lt;/p&gt;

&lt;p&gt;We see that C, by the definition of the AND operator is only true if both \( A \) and \( B \) are true simultaneously.
We can also remark that the same reasoning applies in English: For us not to be liars when we say “I have brown eyes and I possess a car”, then we must both have brown eyes and possess a car.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Axiom&lt;/strong&gt;: The AND operator applied on two propositions \( A \), \( B \) is equivalent to saying “\( A \) and \( B \)” as we understand it in English.&lt;/p&gt;

&lt;h2 id=&quot;or&quot;&gt;OR&lt;/h2&gt;

&lt;p&gt;Let me define the OR operator as being false only if both \( A \) and \( B \) are false simultaneously.
I also define the following notation to represent it: \( A \vee B \).&lt;/p&gt;

&lt;p&gt;Here is the truthtable of the OR operator:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;\( A \)&lt;/th&gt;
      &lt;th&gt;\( B \)&lt;/th&gt;
      &lt;th&gt;\( A \vee B \)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;F&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Remark: the OR operator does not correspond to the English “or”.
Let’s remark that when someone says “I can have an apple or a banana”, what is meant is that the person can have &lt;em&gt;either&lt;/em&gt; an apple or a banana, but not both.
The OR operator would mean that you can have one or both.&lt;/p&gt;

&lt;p&gt;We pretend that the OR operator is equivalent to saying “A or B or both”.&lt;/p&gt;

&lt;h2 id=&quot;precedence-rules&quot;&gt;Precedence Rules&lt;/h2&gt;

&lt;p&gt;For complex expressions involving many operators, we need to know in which order the operators are to be applied.&lt;/p&gt;

&lt;p&gt;We arbitrarily define the following order:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Negation&lt;/li&gt;
  &lt;li&gt;AND&lt;/li&gt;
  &lt;li&gt;OR&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We will use parenthesis to modify the order in which to apply the operators, in the following way: the operators inside a parenthesis should be applied before the operators outside of the parenthesis.&lt;/p&gt;

&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;These only three operators are enough for all the boolean logic.
They allow us to represent every possible operation on any number of input variables.
However, for the sake of brevity and simplicity, it is often preferable to define some more operators; two, in fact, that also have meaning in the spoken language.
This will be the topic of the next article: &lt;a href=&quot;/ASARPhiB//complex-boolean-operators&quot;&gt;Complex Boolean Operators&lt;/a&gt;&lt;/p&gt;</content><author><name>Jonathan Bennett</name></author><category term="Getting started" /><category term="Logic" /><summary type="html">A strong and correct reasoning must, at the very least, be rooted in a rock solid logic. This article tries to explain the basics of the boolean logic, one of the most commonly used logic in mathematics.</summary></entry></feed>